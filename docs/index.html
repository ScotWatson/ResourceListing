<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <!--
(c) 2024 Scot Watson  All Rights Reserved
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    -->
    <title>Resource Listing</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <style>
@keyframes loading {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
    </style>
    <!-- window-init.js must be loaded classically to ensure capture of page load events -->
    <script id="Init" src="https://scotwatson.github.io/WebInterface/window-init.js"></script>
    <!-- MessageQueue.js must be loaded classically to ensure capture of page load events -->
    <script id="MessageQueue" src="https://scotwatson.github.io/WebInterface/MessageQueue.js"></script>
  </head>
  <body>
    <script>
const appLoading = document.createElement("p");
appLoading.style.fontSize = "24pt";
appLoading.style.animation = "loading 1s";
appLoading.innerHTML = "Loading App...";
document.body.append(appLoading);
const appError = document.createElement("p");
appError.style.display = "none";
appError.innerHTML = "This app has encountered an error and has to close";
document.body.append(appError);
const Init = document.getElementById("Init").exports;
const MessageQueue = document.getElementById("MessageQueue").exports.default;
Init.createQueues(MessageQueue);
const serviceWorkerUrl = new URL("./sw.js", Init.selfUrl);
const serviceWorkerScope = new URL("./", Init.selfUrl);
//IIFE to prevent polluting the global namespace
(() => {
  const pathSegments = Init.selfUrl.pathname.split("/");
  if (pathSegments.length !== 0) {
    pathSegments[pathSegments.length - 1] = "";
  }
  const scopeURI = Init.selfUrl.origin + pathSegments.join("/");
  (async () => {
    function getRequestedVersion() {
      const version = Init.selfUrl.searchParams.get("version");
      Init.selfUrl.searchParams.delete("version")
      window.history.replaceState(null, "", Init.selfUrl);
      return version;
    }
    async function getStoredVersion() {
      const SiteStorage = (await import("https://scotwatson.github.io/WebInterface/SiteStorage.mjs")).default;
      const scopedSessionStorage = new SiteStorage({
        uri: scopeURI,
        storage: window.sessionStorage,
      });
      return scopedSessionStorage.get("version");
    }
    async function getLatestVersion() {
      async function installServiceWorker(ServiceWorkers) {
        const newestWorker = await (async () => {
          const installing = await ServiceWorkers.getNewest();
          if (installing) {
            return installing;
          }
          return await ServiceWorkers.installNew({
            url: serviceWorkerUrl,
            scope: serviceWorkerScope,
          });
        })();
        await (async () => {
          let newestWorkerInstalled = false;
          newestWorker.installed.then(() => {
            newestWorkerInstalled = true;
          });
          // Once a service worker has started activating, it cannot fail.
          // Send "claimClients" command to make the active worker the controller.
          // This overrides the default Ctrl-R behavior.
          newestWorker.activating.then(() => {
            newestWorker.input("claimClients");
          });
          await Promise.race([ Init.controller.next().then(() => {
            // controller installed
          }), newestWorker.redundant.then(() => {
            if (!newestWorkerInstalled) {
              console.error("Newest Service Worker failed to install.");
              throw Error("Newest Service Worker failed to install.");
            }
          }) ]);
        })();
        return ServiceWorkers;
      }
      const ServiceWorkers = import("https://scotwatson.github.io/WebInterface/service-workers.mjs").then(installServiceWorker);
      const controllerSource = ServiceWorkers.createControllerSource(Init.controllerMessages);
      newestWorker.input("getVersion");
      return controllerSource[Symbol.asyncIterator].next().then((version) => {
        Init.controllerMessages.stop();
        return version;
      });
      Init.controllerMessages.start();
    }
    try {
      const [ requestedVersion, storedVersion, latestVersion ] = await Promise.all([ getRequestedVersion(), getStoredVersion(), getLatestVersion() ]);
      const version = (() => {
        if (requestedVersion) { return requestedVersion; }
        if (storedVersion) { return storedVersion; }
        return latestVersion;
      })();
      const versionBaseUrl = new URL("./" + version + "/", Init.selfUrl);
      await import("https://scotwatson.github.io/WebInterface/resources.mjs").then(async (Resources) => {
        Resources.addStyleSheet(new URL("./style.css", versionBaseUrl)),
        Resources.addShortcutIcon(new URL("./favicon.ico", Init.selfUrl)),
        Resources.addIcon(new URL("./favicon.ico", Init.selfUrl)),
        await Promise.all([
          Resources.addScript({
            url: new URL("./index.js", versionBaseUrl),
            defer: true,
            asModule: true,
          }).loading,
        ]).then(() => {
          appLoading.style.display = "none";
          appError.style.display = "none";
        }, (e) => {
          console.log("Error on loading index.js");
          console.error(e);
        });
      });
    } catch (e) {
      console.error(e);
      appLoading.style.display = "none";
      appError.style.display = "block";
    }
  })();
})();
    </script>
  </body>
</html>
